
1.选择排序


    public static int[] selectionSort(int[]arr){
        if(arr == null || arr.length < 2){
            return arr;
        }
        for(int i = 0;i < arr.length - 1;i++){
            int minIndex = i;
            for(int j = i + 1;j < arr.length;j++){      //循环一次找到最小值下标
                //若当前数小于minIndex所记录的数，则更新最小值下标
                minIndex = arr[j] < arr[minIndex] ? j : minIndex;
            }
            swap(arr,i,minIndex);                       //将记录的最小值的下标，进行交换，完成一次选择排序
        }
        return arr;
    }



2. 冒泡排序


    public static int[] bubbleSort(int[] arr) {
        if(arr == null || arr.length < 2){
            return arr;
        }
        for(int i = arr.length-1;i > 0;i--){        //每次冒泡一次，从 0-n-1 减小一次
            for(int j = 0;j < i;j++){
                if(arr[j] > arr[j+1]){              //每次把大的数往后冒泡
                    swap(arr,j,j+1);
                }
            }
        }
        return arr;
    }




3. 异或运算  ： 相同为0，不同为1



			1 ^ 0 = 1
			0 ^ 1 = 1

			1 ^ 1 = 0
			0 ^ 0 = 0


		1.	异或运算可以理解为无进位相加


		2.	异或运算满足交换，结合，且与异或的先后顺序无关

		3.  两数a,b进行交换，可以采用 异或的方式
			
			
			前提条件：a , b在内存空间中地址不同
			
			
			数组中使用，前提条件，arr[i] != arr[j]

			


3.1  数组中有 一种数出现奇数次，其他数出现偶数次，找出出现奇数次的数 ？


		将数组中的数全部进行一边异或操作，偶数次的数异或完得到0，最终只剩下出现奇数次的数
		
		
		例：  123211313  等价于  1111 22 333	0 0 3


		//使用异或运算得到，数组中唯一出现一次的奇数次数字
		public static void odd_one(int[]arr){
			int eor = 0;
			for (int i : arr) {
				eor ^= i;
			}
			System.out.println("出现奇数次的数为：" + eor);
		}




3.2  数组中有 两种数出现奇数次，其他数出现偶数次，找出出现奇数次的两个数ab ？
	
	
	
	1.首先将数组中的数全部异或一遍，得到 a ^ b
	
	2，因为 eor = a ^ b 不等于0，可知a b 两个数在二进制某一位上一定不相同
		
		因此可以将数分为两部分，一个是某一位上为1的数，一个是某一位上不为1的数
		
	3. 选择 a ^ b的最右边的1  ：  int rightOne = eor & ( ~eor + 1 )
	
	4.将 rightone与位数为1(或者位数为0)的数全部异或，则得到 a或者b中的某个数
	
	


		public static void odd_two(int[]arr){
			int eor = 0;
			for (int i : arr) {
				eor ^= i;           //得到 eor = a ^ b      a ,b 在某一位上一定不相同
			}

			int rightOne = eor & (~eor + 1);     //取出最右的 1			0000000010000000

			int onlyOne = 0;
			for (int i : arr) {
				if((rightOne & i) == 0){        //将某位数为0的数全部进行异或
					onlyOne ^= i;
				}
			}
			System.out.println(onlyOne + " " + (eor ^ onlyOne));
		}





4.  插入排序


		每一次都将当前所遍历到的数和前面有序的数进行比较



		public static int[] insertSort(int[] arr) {
			if(arr == null || arr.length < 2){
				return arr;
			}

			for (int i = 1; i < arr.length; i++) {  //每一次都将当前index 和前面有序的数进行比较
				for (int j = i-1; j >= 0 && arr[j] > arr[j+1] ; j--) {   //当 j >=0 并且 当前的数要比有序数组中的数要小，才循环
						swap(arr,j,j+1);
				}
			}
			return arr;
		}






5.二分法 详解与二分法的扩展


	5.1  有序数组中，找出某个数是否存在
		
		
		
			采用二分法：
				
				1.从数组的两端开始，left=0  right=arr.length-1、
				
				2.mid = left + (right-left) / 2
				
				3.判断mid和target的大小：
					
					若 arr[mid] == target: 	 找到target，返回结果
					若 arr[mid] > target :   目标在左侧，缩小右边界, right = mid - 1;
					若 arr[mid] < target :   目标在右侧，增大左边界，left = mid + 1
				
				
				
				
			代码：	
			
				public static boolean binarySearch(int[]arr,int target){
					if(arr == null || arr.length == 0){
						return false;
					}
					int left = 0,right = arr.length-1;
					int mid = 0;
					while(left < right){
						mid = left + (right - left) / 2;
						if(arr[mid] == target){
							return true;
						}else if(arr[mid] > target){	//目标在左侧
							right = mid - 1;
						}else{
							left = mid + 1;				//目标在右侧
						}
					}
					return false;
				}



	
	
	
	5.2  在一个有序数组中，找 >= 某个数最左侧的位置



			11122233334444555	
			
			1.当二分查找mid等于target时，此时可能还有更左侧的位置： 
				
				index = mid
				right = mid - 1	
			
			2.继续进行二分
			
			
				
			代码：
			
				public static int binarySearch_left(int[]arr,int target){
					if(arr == null || arr.length == 0){
						return -1;
					}
					int left = 0,right = arr.length-1,mid=0;
					int index = 0;
					while(left < right){
						mid = left + (right-left) / 2;
						if(arr[mid] == target){     //此时 arr[mid] == target,可能还有更左侧的位置
							index = mid;
							right = mid - 1;
						}else{
							left = mid + 1;
						}
					}
					return index;
				}






	5.3 局部最小值 问题

			
	
		  mid 左侧某个数left 比 mid 大
		  mid 右侧某个数right 比 mid 大
		  
		  
		  则在left和right之间，一定存在某个局部最小值，可以使用二分查找































